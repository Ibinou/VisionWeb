<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Fixed Window with Stereo View</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #enter-ar {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background-color: white;
      border: none;
      cursor: pointer;
      display: none;
    }
  </style>
</head>
<body>
  <button id="enter-ar">Enter AR</button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    let camera, scene, renderer;
    let arWindow, xrHitTestSource, xrAnchor;
    let windowVisible = false;
    let distanceThreshold = 5;

    // Initialisation de la scène
    init();
    animate();

    function init() {
      // Créer la scène Three.js
      scene = new THREE.Scene();

      // Configurer la caméra avec un rendu stéréo pour Google Cardboard
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.xr.setFramebufferScaleFactor(2.0);  // Améliorer la qualité du rendu
      renderer.xr.setReferenceSpaceType('local-floor');
      document.body.appendChild(renderer.domElement);

      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
          if (supported) {
            document.getElementById('enter-ar').style.display = 'block';
          }
        });
      }

      // Créer une fenêtre AR
      const geometry = new THREE.PlaneGeometry(1.2, 0.8);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
      arWindow = new THREE.Mesh(geometry, material);
      arWindow.visible = false;  // La fenêtre ne sera visible que lorsque placée
      scene.add(arWindow);

      window.addEventListener('resize', onWindowResize, false);
      document.getElementById('enter-ar').addEventListener('click', startARSession);
    }

    function startARSession() {
      navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['local-floor', 'hit-test'],
        optionalFeatures: ['dom-overlay', 'camera-access']
      }).then((session) => {
        renderer.xr.setSession(session);

        // Définir le hit-test source pour ancrer l'objet
        session.requestReferenceSpace('viewer').then((refSpace) => {
          session.requestHitTestSource({ space: refSpace }).then((hitTestSource) => {
            xrHitTestSource = hitTestSource;
          });
        });

        session.addEventListener('select', () => {
          // Placeholder: actions interactives futures
        });

        session.addEventListener('end', () => {
          xrHitTestSource = null;
          xrAnchor = null;
        });
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame) {
      if (renderer.xr.isPresenting && xrHitTestSource) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const viewerPose = frame.getViewerPose(referenceSpace);

        const hitTestResults = frame.getHitTestResults(xrHitTestSource);
        if (hitTestResults.length > 0 && !xrAnchor) {
          const hit = hitTestResults[0];
          const hitPose = hit.getPose(referenceSpace);

          // Créer un anchor pour fixer la fenêtre à la position
          xrAnchor = renderer.xr.createAnchor(hitPose.transform, referenceSpace);

          // Placer la fenêtre à l'endroit de l'anchor
          arWindow.position.copy(hitPose.transform.position);
          arWindow.visible = true;
        }

        // Ajuster la visibilité selon la distance avec l'utilisateur
        if (xrAnchor) {
          const userPosition = renderer.xr.getCamera(camera).position;
          const distanceToWindow = userPosition.distanceTo(arWindow.position);

          if (distanceToWindow > distanceThreshold) {
            if (windowVisible) {
              arWindow.visible = false;
              windowVisible = false;
            }
          } else {
            if (!windowVisible) {
              arWindow.visible = true;
              windowVisible = true;
            }
          }
        }
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
