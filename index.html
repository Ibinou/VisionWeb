<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Fixed Window with Stereo View</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #enter-ar {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background-color: white;
      border: none;
      cursor: pointer;
    }
    .left-eye, .right-eye {
      position: absolute;
      width: 50%;
      height: 100%;
      top: 0;
    }
    .left-eye {
      left: 0;
    }
    .right-eye {
      right: 0;
    }
  </style>
</head>
<body>
  <button id="enter-ar">Enter AR</button>
  <div class="left-eye"></div>
  <div class="right-eye"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    let camera, scene, rendererL, rendererR;
    let arWindow;
    let windowVisible = false;
    let userSetPosition = false;

    // Initialisation de la scène pour chaque œil
    init();
    animate();

    function init() {
      // Créer la scène Three.js
      scene = new THREE.Scene();

      // Configurer la caméra avec un rendu stéréo manuel
      camera = new THREE.PerspectiveCamera(70, 0.5 * window.innerWidth / window.innerHeight, 0.01, 20);

      // Renderer pour l'œil gauche
      rendererL = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      rendererL.setPixelRatio(window.devicePixelRatio);
      rendererL.setSize(window.innerWidth / 2, window.innerHeight);
      document.querySelector('.left-eye').appendChild(rendererL.domElement);

      // Renderer pour l'œil droit
      rendererR = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      rendererR.setPixelRatio(window.devicePixelRatio);
      rendererR.setSize(window.innerWidth / 2, window.innerHeight);
      document.querySelector('.right-eye').appendChild(rendererR.domElement);

      // Créer une fenêtre AR
      const geometry = new THREE.PlaneGeometry(1.2, 0.8);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
      arWindow = new THREE.Mesh(geometry, material);
      arWindow.position.set(0, 1.5, -2); // Position initiale par défaut
      scene.add(arWindow);

      window.addEventListener('resize', onWindowResize, false);
      document.getElementById('enter-ar').addEventListener('click', startARSession);
    }

    function startARSession() {
      if (navigator.xr) {
        navigator.xr.requestSession('immersive-ar', { optionalFeatures: ['dom-overlay'] })
        .then((session) => {
          onSessionStarted(session);
        })
        .catch((err) => {
          console.error('AR session failed to start', err);
        });
      } else {
        alert("WebXR is not supported in this browser.");
      }
    }

    function onSessionStarted(session) {
      // Setup AR session
      rendererL.xr.enabled = true;
      rendererR.xr.enabled = true;
      rendererL.xr.setSession(session);
      rendererR.xr.setSession(session);

      session.addEventListener('end', onSessionEnded);

      document.getElementById('enter-ar').style.display = 'none';
    }

    function onSessionEnded() {
      // Désactiver AR si la session est terminée
      rendererL.xr.enabled = false;
      rendererR.xr.enabled = false;
      document.getElementById('enter-ar').style.display = 'block';
    }

    function onWindowResize() {
      camera.aspect = 0.5 * window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      rendererL.setSize(window.innerWidth / 2, window.innerHeight);
      rendererR.setSize(window.innerWidth / 2, window.innerHeight);
    }

    function animate() {
      rendererL.setAnimationLoop(() => render(rendererL));
      rendererR.setAnimationLoop(() => render(rendererR));
    }

    function render(renderer) {
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
